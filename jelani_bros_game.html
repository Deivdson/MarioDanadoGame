<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jelani Bros</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #game-container {
            width: 100%;
            height: 100%;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 20px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="ui">
        <div>Fase: <span id="phase">1</span></div>
        <div>Vidas: <span id="lives">3</span></div>
    </div>
    <button style="position: absolute; top: 10px; right: 230px; background-color: #667eea; color: #fff; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; z-index: 100;" onclick="window.location.href='index.html'">üè† Menu</button>
    <button style="position: absolute; top: 10px; right: 120px; background-color: #ffd700; color: #000; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; z-index: 100;" onclick="window.location.href='jelani_bros_fase2.html'">Fase 2 ‚Üí</button>
    <button style="position: absolute; top: 10px; right: 10px; background-color: #9b59b6; color: #fff; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; z-index: 100;" onclick="window.location.href='jelani_bros_fase3.html'">Fase 3 ‚Üí</button>

    <script>
        const config = {
            type: Phaser.AUTO,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: 800,
                height: 400
            },
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 300 },
                    debug: false
                }
            },
            scene: {
                init: init,
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        let player, platforms, enemies, victoryArea, cursors;
        let currentPhase = 1;
        let lives = 3;
        let lastDirection = 'down';

        function init() {
            this.registry.set('phase', currentPhase);
            this.registry.set('lives', lives);
        }

        function preload() {
            // Carregar imagens
            this.load.image('jelani', 'assets/jelani.png');
            this.load.image('enemy', 'assets/enemy.gif');
            this.load.image('xuxu', 'assets/xuxu.png');
        }

        function create() {
            const scene = this;
            
            // Ground texture
            const graphics = this.make.graphics({ fillStyle: { color: 0x2c6b2c } });
            graphics.fillRect(0, 0, 1, 1);
            graphics.generateTexture('ground', 1, 1);
            graphics.destroy();

            // Victory texture
            const victoryGraphics = this.make.graphics({ fillStyle: { color: 0xffd700 } });
            victoryGraphics.fillRect(0, 0, 1, 1);
            victoryGraphics.generateTexture('victory', 1, 1);
            victoryGraphics.destroy();
            
            this.physics.world.setBounds(0, 0, 800, 400);

            // Platforms
            platforms = this.physics.add.staticGroup();
            platforms.create(400, 380, 'ground').setScale(800, 20).refreshBody();

            // Fases progressivas
            if (currentPhase === 1) {
                platforms.create(150, 250, 'ground').setScale(100, 20).refreshBody();
                platforms.create(500, 200, 'ground').setScale(150, 20).refreshBody();
                platforms.create(750, 150, 'ground').setScale(100, 20).refreshBody();
            } else if (currentPhase === 2) {
                platforms.create(100, 280, 'ground').setScale(80, 20).refreshBody();
                platforms.create(250, 220, 'ground').setScale(80, 20).refreshBody();
                platforms.create(400, 180, 'ground').setScale(100, 20).refreshBody();
                platforms.create(600, 220, 'ground').setScale(80, 20).refreshBody();
                platforms.create(750, 150, 'ground').setScale(80, 20).refreshBody();
            } else if (currentPhase >= 3) {
                platforms.create(80, 300, 'ground').setScale(60, 20).refreshBody();
                platforms.create(200, 250, 'ground').setScale(70, 20).refreshBody();
                platforms.create(350, 200, 'ground').setScale(70, 20).refreshBody();
                platforms.create(500, 250, 'ground').setScale(70, 20).refreshBody();
                platforms.create(650, 180, 'ground').setScale(70, 20).refreshBody();
                platforms.create(750, 280, 'ground').setScale(60, 20).refreshBody();
            }

            // Player
            player = this.physics.add.sprite(100, 200, 'jelani');
            player.setScale(0.1); // Imagem original √© 484x515, reduzindo para ~48x51 pixels
            player.setBounce(0.2);
            player.setCollideWorldBounds(true);
            player.originalScale = 0.1;
            player.crouchScale = 0.06;
            player.isCrouching = false;
            this.physics.add.collider(player, platforms);

            // Inimigos (usando enemy.gif)
            enemies = this.physics.add.group();
            const enemyCount = Math.min(1 + currentPhase, 4);
            const enemySpeed = 100 + currentPhase * 30;

            for (let i = 0; i < enemyCount; i++) {
                const xPos = 150 + i * 150;
                const yPos = 120 + (i % 2) * 80;
                const enemy = enemies.create(xPos, yPos, 'enemy');
                enemy.setScale(0.15); // Reduzido para 15% do tamanho original
                enemy.setBounce(1);
                enemy.setCollideWorldBounds(true);
                enemy.setVelocityX(i % 2 === 0 ? -enemySpeed : enemySpeed);
            }

            // Adicionar xuxu (recupera√ß√£o de vida)
            const xuxus = this.physics.add.group();
            const xuxuPositions = [
                { x: 300, y: 340 },
                { x: 650, y: 270 }
            ];
            
            xuxuPositions.forEach(pos => {
                const xuxu = xuxus.create(pos.x, pos.y, 'xuxu');
                xuxu.setScale(0.05);
                xuxu.body.allowGravity = false;
                xuxu.body.immovable = true;
            });

            // Colis√£o para coletar xuxu e recuperar vida
            this.physics.add.overlap(player, xuxus, (player, xuxu) => {
                xuxu.destroy();
                lives++;
                document.getElementById('lives').textContent = lives;
                
                // Efeito visual de texto
                const lifeText = scene.add.text(xuxu.x, xuxu.y - 20, '+1 VIDA', {
                    fontSize: '20px',
                    fill: '#00ff00',
                    fontStyle: 'bold'
                });
                scene.tweens.add({
                    targets: lifeText,
                    y: lifeText.y - 50,
                    alpha: 0,
                    duration: 1000,
                    onComplete: () => lifeText.destroy()
                });
            }, null, this);

            this.physics.add.collider(enemies, platforms);
            this.physics.add.collider(player, enemies, () => {
                lives--;
                document.getElementById('lives').textContent = lives;

                if (lives <= 0) {
                    alert('Game Over! Voc√™ perdeu todas as vidas.');
                    currentPhase = 1;
                    lives = 3;
                    scene.scene.restart();
                } else {
                    player.setPosition(100, 200);
                }
            }, null, this);

            // Victory Area
            victoryArea = this.physics.add.staticImage(750, 100, 'victory')
                .setScale(50, 50)
                .refreshBody();

            this.physics.add.overlap(player, victoryArea, () => {
                currentPhase++;
                document.getElementById('phase').textContent = currentPhase;
                alert(`Fase ${currentPhase - 1} conclu√≠da! Pr√≥xima fase mais dif√≠cil!`);
                this.scene.restart();
            }, null, this);

            // Camera
            this.cameras.main.setBounds(0, 0, 800, 400);
            this.cameras.main.startFollow(player);

            // Controls
            cursors = this.input.keyboard.createCursorKeys();
            document.getElementById('phase').textContent = currentPhase;
            document.getElementById('lives').textContent = lives;
        }

        function update() {
            // Controle de agachamento
            if (cursors.down.isDown && player.body.touching.down) {
                if (!player.isCrouching) {
                    player.scaleY = player.crouchScale;
                    player.isCrouching = true;
                }
                player.setVelocityX(0);
                lastDirection = 'down';
            } else {
                if (player.isCrouching) {
                    player.scaleY = player.originalScale;
                    player.isCrouching = false;
                }

                if (cursors.left.isDown) {
                    player.setVelocityX(-160);
                    player.setFlipX(true); // Inverte para a esquerda
                    lastDirection = 'left';
                } else if (cursors.right.isDown) {
                    player.setVelocityX(160);
                    player.setFlipX(false); // Dire√ß√£o normal (direita)
                    lastDirection = 'right';
                } else {
                    player.setVelocityX(0);
                }
            }

            if (cursors.up.isDown && player.body.touching.down && !player.isCrouching) {
                player.setVelocityY(-330);
                lastDirection = 'up';
            }
        }
    </script>
</body>
</html>